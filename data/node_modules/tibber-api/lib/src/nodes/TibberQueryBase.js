"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TibberQueryBase = void 0;
const url = __importStar(require("url"));
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const HttpMethod_1 = require("./models/HttpMethod");
const websocketSubscriptionUrl_1 = require("../gql/websocketSubscriptionUrl");
const home_gql_1 = require("../gql/home.gql");
const TimeoutError_1 = require("./models/TimeoutError");
const HeaderManager_1 = require("../tools/HeaderManager");
class TibberQueryBase {
    get requestTimeout() {
        return this._requestTimeout;
    }
    set requestTimeout(value) {
        this._requestTimeout = value;
    }
    get config() {
        return this._config;
    }
    set config(value) {
        this._config = value;
    }
    /**
     *
     */
    constructor(config, requestTimeout = 30000) {
        this.active = false;
        this._config = config;
        this._headerManager = new HeaderManager_1.HeaderManager(config);
        this._requestTimeout = requestTimeout > 1000 ? requestTimeout : 1000;
    }
    /**
     * Try to parse a string and return a valid JSON object.
     * If string is not valid JSON, it will return an empty object instead.
     * @param input Input string to try to parse as a JSON object
     * @returns Parsed or empty Json object
     */
    JsonTryParse(input) {
        try {
            // check if the string exists
            if (input) {
                const o = JSON.parse(input);
                // validate the result too
                if (o && o.constructor === Object) {
                    return o;
                }
            }
        }
        catch (e) {
            // TODO: Add logging.
        }
        return { responseMessage: input };
    }
    ;
    /**
     *
     * @param method HTTP method to use
     * @param uri Uri to use
     * @returns An object containing request options
     */
    getRequestOptions(method, uri) {
        return {
            host: uri.host,
            port: uri.port,
            path: uri.path,
            protocol: uri.protocol,
            method,
            headers: {
                Connection: 'Keep-Alive',
                Accept: 'application/json',
                Host: uri.hostname,
                'User-Agent': this._headerManager.userAgent,
                'Content-Type': 'application/json',
                Authorization: `Bearer ${this._config.apiEndpoint.apiKey}`,
            },
        };
    }
    /**
     * General GQL query
     * @param query GQL query.
     * @param variables Variables used by query parameter.
     * @return Query result as JSON data
     */
    async query(query, variables) {
        return await new Promise((resolve, reject) => {
            try {
                const uri = url.parse(this._config.apiEndpoint.queryUrl, true);
                const options = this.getRequestOptions(HttpMethod_1.HttpMethod.Post, uri);
                const data = new TextEncoder().encode(JSON.stringify({
                    query,
                    variables,
                }));
                const client = (uri.protocol === "https:") ? https_1.default : http_1.default;
                const req = client.request(options, (res) => {
                    let str = '';
                    res.on('data', (chunk) => {
                        str += chunk;
                    });
                    res.on('end', () => {
                        const response = this.JsonTryParse(str);
                        const statusCode = Number(res === null || res === void 0 ? void 0 : res.statusCode);
                        if (statusCode >= 200 && statusCode < 300) {
                            resolve(response.data ? response.data : response);
                        }
                        else {
                            response.httpCode = res === null || res === void 0 ? void 0 : res.statusCode;
                            response.statusCode = res === null || res === void 0 ? void 0 : res.statusCode;
                            response.statusMessage = res === null || res === void 0 ? void 0 : res.statusMessage;
                            reject(response);
                        }
                        req.destroy();
                    });
                });
                req.on('error', (e) => {
                    reject(e);
                });
                req.setTimeout(this._requestTimeout, () => {
                    req.destroy(new TimeoutError_1.TimeoutError(`Request imeout for uri ${uri}`));
                });
                if (data) {
                    req.write(data);
                }
                req.end();
            }
            catch (error) {
                reject(error);
            }
        });
    }
    /**
     * Get selected home with some selected properties, including address and owner.
     * @param homeId Tibber home ID
     * @return IHome object
     */
    async getWebsocketSubscriptionUrl() {
        const result = await this.query(websocketSubscriptionUrl_1.qglWebsocketSubscriptionUrl);
        if (result && result.viewer && result.viewer.websocketSubscriptionUrl) {
            return new url.URL(result.viewer.websocketSubscriptionUrl);
        }
        return result && result.error ? result : {};
    }
    /**
     * Get selected home with some selected properties, including address and owner.
     * @param homeId Tibber home ID
     * @return IHome object
     */
    async getRealTimeEnabled(homeId) {
        var _a, _b, _c, _d;
        const variables = { homeId };
        const result = await this.query(home_gql_1.gqlHomeRealTime, variables);
        return (_d = (_c = (_b = (_a = result === null || result === void 0 ? void 0 : result.viewer) === null || _a === void 0 ? void 0 : _a.home) === null || _b === void 0 ? void 0 : _b.features) === null || _c === void 0 ? void 0 : _c.realTimeConsumptionEnabled) !== null && _d !== void 0 ? _d : false;
    }
}
exports.TibberQueryBase = TibberQueryBase;
//# sourceMappingURL=TibberQueryBase.js.map